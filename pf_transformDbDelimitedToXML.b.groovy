/* @data
FG5764|^|05C|^|1|^|Acidic Species|^|45.0|^|2.0|^|6.0|^|0.166666666666667|^||^|iCE|^|\\amrsomw557\Informa-reports\Non-GMP\BCMA\Stability\Filing\DP Cross Source\BCMA DP Scatterplot Stability Charts_files\BCMA:Kalamazoo:Drug Product:05C:Acidic Species {%}.png|^||^||^||^|BCMA:Kalamazoo:Drug Product:05C:Acidic Species {%}|^|20210929 174709.000|^|Pfizer|^|Kalamazoo|^|H000025594|^||^|45.6|^||^||^|%|^|Acidic Species {%}|^||^||^||^||^||^||^||^|BCMA|^|PF-06863135:1|^|P|^|31.0|^|PF-06863135:1-023|^|GEN_REGIST|^|FG5764|^|4.0|^|0.0833333333333333|^|7.9958524E7|^|7.9958524E7|^|1183791.0|^|20210903 131153.000|^|62.0|^||^|Result <= MAX|^|<= 62.0% Acidic Species|^|INVERTED|^|20210726 000000.000|^|Drug Product|^|20210917 223428.000|^|20210909 143837.000|^|20210826 000000.000|^|1 M|^|45.6|^||^||^||^||^||^||^||^|<= 62.0% Acidic Species
FG5764|^|05C|^|1|^|asdf pH [unrounded]|^|48.0|^|1.0|^|7.0|^|0.0833333333333333|^||^|pH|^||^||^||^||^|BCMA:Kalamazoo:Drug Product:05C:pH|^|20210915 164954.000|^|Pfizer|^|Kalamazoo|^|H000025594|^||^|5.7|^||^||^|-|^|pH|^||^||^||^||^||^||^||^|BCMA|^||^|ACTIVE|^|48.0|^|FG5764|^|H000025594 STABILITY|^|VIAL - 5 ML|^|7.0|^|0.0833333333333333|^|4.29822838E8|^|4.29822838E8|^|2.09463715E8|^|20210823 020232.000|^|6.3|^|5.3|^|5.3 - 6.3|^|NONE|^|INVERTED|^|20210706 000000.000|^|Drug Product|^||^|20210823 020232.000|^|20210823 020232.000|^|1 M|^|5.7|^||^||^||^||^||^||^||^|NONE
FG5764|^|05C|^|1|^|Fragments|^|51.0|^|2.0|^|7.0|^|0.166666666666667|^||^|CGE (non-reducing)|^|\\amrsomw557\Informa-reports\Non-GMP\BCMA\Stability\Filing\DP Cross Source\BCMA DP Scatterplot Stability Charts_files\BCMA:Kalamazoo:Drug Product:05C:Fragments {%}.png|^||^||^||^|BCMA:Kalamazoo:Drug Product:05C:Fragments {%}|^|20210929 174709.000|^|Pfizer|^|Kalamazoo|^|H000025594|^||^|0.3|^||^|<|^|%|^|Fragments {%}|^||^||^||^||^||^||^||^|BCMA|^|PF-06863135:1|^|P|^|31.0|^|PF-06863135:1-023|^|GEN_REGIST|^|FG5764|^|4.0|^|0.0833333333333333|^|7.9958491E7|^|7.9958491E7|^|1183791.0|^|20210903 131153.000|^|5.0|^||^|Result <= MAX|^|<= 5.0 % Fragments|^|INVERTED|^|20210726 000000.000|^|Drug Product|^|20210917 223428.000|^|20210915 163059.000|^|20210826 000000.000|^|1 M|^|NMT 0.3|^||^||^||^||^||^||^||^|<= 5.0 % Fragments
FG5764|^|05C|^|1|^|Clarity [unrounded]|^|48.0|^|1.0|^|7.0|^|0.0833333333333333|^||^|Appearance|^||^||^||^||^|BCMA:Kalamazoo:Drug Product:05C:Clarity {NTU}|^|20210923 125739.000|^|Pfizer|^|Kalamazoo|^|H000025594|^||^|6.0|^||^||^|NTU|^|Clarity {NTU}|^||^||^||^||^||^||^||^|BCMA|^||^|ACTIVE|^|48.0|^|FG5764|^|H000025594 STABILITY|^|VIAL - 5 ML|^|7.0|^|0.0833333333333333|^|4.29822839E8|^|4.29822839E8|^|2.09463715E8|^|20210823 020232.000|^|18.0|^||^|<= 18|^|NEPHELOMETRIC TURBIDITY UNITS|^|INVERTED|^|20210706 000000.000|^|Drug Product|^||^|20210823 020232.000|^|20210823 020232.000|^|1 M|^|6|^||^||^||^||^||^||^||^|NEPHELOMETRIC TURBIDITY UNITS
*/

/* @Props
DPP_ColumnNames="Batch Number", "Stab Storage Condition", "Protocol Months On Stability", "Parameter Field Name", "Actual Days On Stability", "Actual Months On Stability", "Actual Weeks On Stability", "Actual Years On Stability", "Assay Method", "Assay Name", "Chart Image Location", "Date Parameter Value", "Date of Manufacture", "Days On Stability since DOM", "Grouping Parameter", "Last Modification Date", "Manufacture Company", "Manufacture Site", "Material Number", "Months On Stability since DOM", "Numeric Parameter Value", "Parameter Category", "Parameter Entry Qualifier", "Parameter Units", "Parameter _w_Units_ Field Name", "Process Variation", "Product Category 1 Name", "Product Category 1 Value", "Product Category 2 Name", "Product Category 2 Value", "Product Category 3 Name", "Product Category 3 Value", "Product Name", "Project Name", "Project Status", "Protocol Days On Stability", "Protocol Name", "Protocol Template", "Protocol Test Article", "Protocol Weeks On Stability", "Protocol Years On Stability", "Result ID", "Result Number", "Sample Number", "Sample Start Date", "Spec Max Value", "Spec Min Value", "Spec Rule", "Spec Text Value", "Stab Storage Orientation", "Stability Base Date", "Sub Product Name", "Test Review Date", "Test Start Date", "Testing Target Date", "Testing Time Point", "Text Parameter Value", "Validation State", "Weeks On Stability since DOM", "Worklist Name", "Years On Stability since DOM", "Investigation", "Serotype", "Suite", "Spec Description"
DPP_UsedColumns="Parameter Field Name","Assay Name","Numeric Parameter Value","Parameter Units","Spec Max Value","Spec Min Value","Spec Rule","Spec Text Value","Text Parameter Value", "Spec Description"
DPP_AssayNamesColIndex=9
DPP_FieldNamesColIndex=3
DPP_FieldValueColIndex=56

document.dynamic.userdefined.DDP_LotNumber=LOT123
document.dynamic.userdefined.DDP_UsedFieldsCsv=pH|^|pH|^|1|^|4|^|4|^|n\nCGE (non-reducing)|^|Fragments|^|2|^|16|^|10|^|n\nAppearance|^|Clarity|^|1|^|2|^|7|^|n\n
document.dynamic.userdefined.DDP_GroupByValue=0.0
document.dynamic.userdefined.DDP_GroupByLabel=Time(Months)
*/

import java.util.Properties;
import java.io.InputStream;
import com.boomi.execution.ExecutionUtil;
import groovy.xml.MarkupBuilder;

logger = ExecutionUtil.getBaseLogger();

def dataColumnDelimiter = /\|\^\|/
// logger.warning("dataColumnDelimiter: " + dataColumnDelimiter)

// get DPPs from Constants
def dbAllColumns = ExecutionUtil.getDynamicProcessProperty("DPP_ColumnNames")
// logger.warning("dbAllColumns: " + dbAllColumns)
def dbAllColumnsArr = dbAllColumns.trim().split(/\s*,\s*/)
// logger.warning("dbAllColumnsArr: " + dbAllColumnsArr)
def dbUsedColumns = ExecutionUtil.getDynamicProcessProperty("DPP_UsedColumns")
// logger.warning("dbUsedColumns: " + dbUsedColumns)
def dbUsedColumnsArr = dbUsedColumns.trim().split(/\s*,\s*/)
// logger.warning("dbUsedColumnsArr: " + dbUsedColumnsArr)
int dbAssayNameColIndex = ExecutionUtil.getDynamicProcessProperty("DPP_AssayNamesColIndex") as int
// logger.warning("dbAssayNameColIndex: " + dbAssayNameColIndex.toString())
int dbFieldNameColIndex = ExecutionUtil.getDynamicProcessProperty("DPP_FieldNamesColIndex") as int
// logger.warning("dbFieldNameColIndex: " + dbFieldNameColIndex.toString())
int dbFieldValueColIndex = ExecutionUtil.getDynamicProcessProperty("DPP_FieldValueColIndex") as int
// logger.warning("dbFieldValueColIndex: " + dbFieldValueColIndex.toString())

for( int i = 0; i < dataContext.getDataCount(); i++ ) {
    InputStream is = dataContext.getStream(i);
    Properties props = dataContext.getProperties(i);
    
    reader = new BufferedReader(new InputStreamReader(is));
    
    // get DDPs
    def dbLotNumber = props.getProperty("document.dynamic.userdefined.DDP_LotNumber")
    // logger.warning("dbLotNumber: " + dbLotNumber)
    
    def usedFields = props.getProperty("document.dynamic.userdefined.DDP_UsedFieldsCsv")
    // logger.warning("usedFields: " + usedFields)
    def usedFieldsArr = usedFields.trim().split("\n")
    // logger.warning("usedFieldsArr: " + usedFieldsArr)
    
    def dbGroupByValue = props.getProperty("document.dynamic.userdefined.DDP_GroupByValue")
    // logger.warning("dbGroupByValue: " + dbGroupByValue)
    def dbGroupByLabel = props.getProperty("document.dynamic.userdefined.DDP_GroupByLabel")
    // logger.warning("dbGroupByLabel: " + dbGroupByLabel)

    // construct usedFieldsMap
    def usedFieldsMap = [:]
    def usedFieldNameList = []
    int numTables = 1
    usedFieldsArr.each() { usedFieldsRowStr ->
        def usedFieldsRowArr = usedFieldsRowStr.trim().split(/\s*\|\^\|\s*/)

        def assay = usedFieldsRowArr[0]
        def parameter = usedFieldsRowArr[1]
        int tableNum = usedFieldsRowArr[2] as int
        def column = usedFieldsRowArr[3]
        def width = usedFieldsRowArr[4]
        
        usedFieldNameList.push(parameter)
        if (tableNum > numTables) numTables = tableNum
        usedFieldsMap."${assay.toUpperCase()}__${parameter.toUpperCase()}" = [assay,parameter,tableNum,column,width]
    }
    // logger.warning("usedFieldsMap: " + usedFieldsMap)
    // logger.warning("usedFieldNameList: " + usedFieldNameList.toString())

    //construct dataRowMap
    def dataRowMap = [:]
    def dataRowArrWidth = 0
    while ((dataRow = reader.readLine()) != null) {
        def dataRowArr = dataRow.split(dataColumnDelimiter)
        usedFieldNameList.each {
          if (dataRowArr[dbFieldNameColIndex].toUpperCase().contains(it.toUpperCase())) {
            dataRowArr[dbFieldNameColIndex] = it
          }
        }
        if (dataRowArrWidth == 0) dataRowArrWidth = dataRowArr.size()
        dataRowMap."${dataRowArr[dbAssayNameColIndex].toUpperCase()}__${dataRowArr[dbFieldNameColIndex].toUpperCase()}" = dataRowArr
        // logger.warning(dataRowArr.size() + ": ${dataRowArr[dbAssayNameColIndex]}__${dataRowArr[dbFieldNameColIndex]}: " + dataRowArr)
    }
    // logger.warning("dataRowMap: " + dataRowMap)

    // Set DDP for use later to separate the one table which is the result of this script into multiple tables
    props.setProperty("document.dynamic.userdefined.DDP_NumTables", numTables.toString())
    // logger.warning("numTables: " + DDP_NumTables)

    // init XML construction
    // http://docs.groovy-lang.org/docs/groovy-2.4.10/html/api/groovy/xml/MarkupBuilder.html [docs.groovy-lang.org] [docs.groovy-lang.org]
    def xmlWriter = new StringWriter()
    def xmlMarkup = new MarkupBuilder(xmlWriter)
    
    // construct XML
    xmlMarkup.'StabilityData'() {
        'Batch'('LotNumber':dbLotNumber) {
            // for each table... allows for reset of columnSequenceNum per table
                    'DataRow'('GroupByLabel':dbGroupByLabel, 'GroupByValue':dbGroupByValue){
            (1..numTables).each() { tableIndex ->
                int columnSequenceNum = 1
                // 'Table'('TableIndex':tableIndex) {
                // 'Table'() {
                        usedFieldsMap.each() { assay__field, indicesArr ->
                            def usedAssay = indicesArr[0]
                            def usedParamater = indicesArr[1]
                            def usedTableIndex = indicesArr[2]
                            def usedColumnIndex = indicesArr[3]
                            def usedWidth = indicesArr[4]
                            
                            if (usedTableIndex == tableIndex) {
                                
                                'Field'('TableIndex':usedTableIndex, 'ColumnIndex':usedColumnIndex,'ColumnSeqence':columnSequenceNum,'ColumnWidth':usedWidth, \
                                            'Key':assay__field) {

                                    // if a field is in the usedFields but not in the data, create a row for it in the data.
                                    if (!dataRowMap."${assay__field}") {
                                        def fillerDataRowArr = []
                                        // fill all fields with N/A except for the ParameterFieldName field,
                                        // fill that with the ParameterFieldName
                                        (0..dataRowArrWidth-1).each() { k ->
                                            // logger.warning("k: " + k + " dbFieldNameColIndex: " + dbFieldNameColIndex)
                                            if (k == dbAssayNameColIndex) fillerDataRowArr[k] = usedAssay
                                            else if (k == dbFieldNameColIndex) fillerDataRowArr[k] = usedParamater
                                            else if (k == dbFieldValueColIndex) fillerDataRowArr[k] = "NT"
                                            else fillerDataRowArr[k] = ""
                                        }
                                        dataRowMap."${assay__field}" = fillerDataRowArr
                                    }
                                    dataRowMap."${assay__field}".eachWithIndex() { rowItem, j ->
                                        // only create and xml node if the column is in the usedDbColunsArr
                                        if (dbUsedColumnsArr.contains(dbAllColumnsArr[j].trim())) {
                                            // logger.warning("TRUE")
                                            "${dbAllColumnsArr[j].replaceAll(/\W/,"")}"("${groovy.json.StringEscapeUtils.escapeJava(rowItem)}")
                                        }
                                    }
                                }
                                columnSequenceNum++
                            }
                        }
                    }
                // }
            }
        }
    }
    // logger.warning(xmlWriter.toString()) //.replaceAll(/>\s+</,"")

    is = new ByteArrayInputStream(xmlWriter.toString().getBytes("UTF-8"));
    dataContext.storeStream(is, props);
}

